---
title: 'Practica 2: Limpieza y validación de los datos'
author: "Anddy Aldave Valle, Alejandro Pulido Duque"
date: "13 de mayo de 2020"
output:
  html_document: default
  pdf_document: default
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## 1. Descripción del dataset. ¿Por qué es importante y qué pregunta/problema pretende responder?

##### Los campos del conjunto de datos son los siguientes
###### x: El número de registro
###### carat: Peso en kilates del diamante
###### cut: La calidad del corte del diamante
###### color: El color del diamante
###### clarity: Califica la apariencia visual de cada diamante
###### depth: La altura de un diamante, medida desde el culet, o base, hasta la tabla, o tope superior, divido por su diámetro medio (z / media(x, y))
###### table: El ancho de la tabla del diamante expresado como un porcentaje de su diámetro medio
###### price: El precio del diamante
###### x: longitud del diamante en mm
###### y: ancho del diamante en mm
###### z: profundidad del diamante en mm


A continuación, para mayor claridad, se incluyen las partes del diamante

![Partes del diamante](diamante.JPG)


## 2. Integración y selección de los datos de interés a analizar. 


## 3. Limpieza de los datos.
```{r,eval=TRUE,echo=TRUE}
# Lectura de datos
diamonds_df <- read.csv("diamonds.csv", header = TRUE, sep=",", dec = ".")
#sapply(diamonds_df,class)
#Ejecutando la funcion summary sobre el dataframe, nos mostrará un resumen de cada variable
summary(diamonds_df)
str(diamonds_df)
```
### 3.1. ¿Los datos contienen ceros o elementos vacíos? ¿Cómo gestionarías cada uno de estos casos? 
```{r,eval=TRUE,echo=TRUE}
#Comprobamos si hay registros con elementos vacíos o NA
sapply(diamonds_df, anyNA)
```
###### Hemos comprobado que no hay ningún registro con elementos vacíos

```{r,eval=TRUE,echo=TRUE}
#Comprobamos si hay registros que contienen ceros
sapply(diamonds_df, function(x) any(x==0))
```
###### Hemos comprobado que las variables x, y, z contienen ceros

###### Un diamante es un objeto que debe tener ancho, altura y profundidad, por lo tanto, asumimos que si alguna de estas variables son 0, es que no se ha medido o hay un error en los datos.
###### Este tipo de problemas, tiene 2 soluciones: Podríamos eliminar estos registros o calcular un nuevo valor según la semejanza de este registro con otros dentro del mismo conjunto de datos.
###### Creemos que eliminar estos registros limitaría nuestro conjunto de datos y ocultaría información que queremos analizar, por ello, imputaremos los valores perdidos a través del modelo basado en los k-vecinos más cercanos. 
###### El modelo Knn encuentra los k vecinos más cercanos según la semejanza de los registros perdidos con los demás registros del juego de datos
```{r,eval=TRUE,echo=TRUE}
suppressWarnings(suppressMessages(library(VIM)))
library(VIM)
#Miramos que registros contienen ceros
indicesx <-which(diamonds_df$x==0)
indicesy <-which(diamonds_df$y==0)
indicesz <-which(diamonds_df$z==0)
#Asignamos el valor de NA a todos los campos que contienen ceros
diamonds_df[indicesx,"x"]<-NA
diamonds_df[indicesy,"y"]<-NA
diamonds_df[indicesz,"z"]<-NA
```
###### Miramos el estado de los registros que contienen ceros en la variable x, antes de la imputación
```{r,eval=TRUE,echo=TRUE}
diamonds_df[indicesx,]
kNNx<-kNN(diamonds_df[,c("cut","color","clarity","depth","table","price","x","y","z")], variable="x",k=3)
diamonds_df[indicesx,"x"]<-kNNx[indicesx,"x"]
```
###### Después de la imputación en la variable x
```{r,eval=TRUE,echo=TRUE}
diamonds_df[indicesx,]
```
###### Miramos el estado de los registros que contienen ceros en la variable y, antes de la imputación
```{r,eval=TRUE,echo=TRUE}
diamonds_df[indicesy,]
kNNy<-kNN(diamonds_df[,c("cut","color","clarity","depth","table","price","x","y","z")], variable="y",k=3)
diamonds_df[indicesy,"y"]<-kNNy[indicesy,"y"]
```
###### Después de la imputación en la variable y
```{r,eval=TRUE,echo=TRUE}
diamonds_df[indicesy,]
```
###### Miramos el estado de los registros que contienen ceros en la variable z, antes de la imputación
```{r,eval=TRUE,echo=TRUE}
diamonds_df[indicesz,]
kNNz<-kNN(diamonds_df[,c("cut","color","clarity","depth","table","price","x","y","z")], variable="z",k=3)
diamonds_df[indicesz,"z"]<-kNNz[indicesz,"z"]
```
###### Después de la imputación en la variable z
```{r,eval=TRUE,echo=TRUE}
diamonds_df[indicesz,]
```
###### Finalmente, volvemos a comprobar si hay registros ceros o elementos vacíos
```{r,eval=TRUE,echo=TRUE}
#Comprobamos si hay registros con elementos vacíos o NA
sapply(diamonds_df, anyNA)
```
```{r,eval=TRUE,echo=TRUE}
#Comprobamos si hay registros que contienen ceros
sapply(diamonds_df, function(x) any(x==0))
```
###### Efectivamente, ya no hay ningún valor cero ni elementos vacío

### 3.2 Identificación y tratamiento de valores extremos. 

Calculamos el volumen de los diamantes, basándonos en sus medidas x, y, z
```{r,eval=TRUE,echo=TRUE}
volume<-diamonds_df$x*diamonds_df$y*diamonds_df$z
diamonds_df<-cbind(diamonds_df,volume)
```

En primer lugar, en esta categoría analizaremos sólo los valores numéricos, para ello, vamos a realizar representaciones de tipo caja de cada una de las variables.

```{r,eval=TRUE,echo=TRUE}
#Representamos cada variable
boxplot(diamonds_df$carat, main="Peso en Kilates", xlab="peso", ylab="kilates")
boxplot(diamonds_df$depth, main="Altura del diamante", xlab="altura", ylab="z / media(x, y)")
boxplot(diamonds_df$table, main="Ancho de la tabla", xlab="tabla", ylab="% respecto al diámetro medio")
boxplot(diamonds_df$price, main="Precio", xlab="precio", ylab="USD")
boxplot(diamonds_df$x, main="Longitud", xlab="longitud", ylab="mm")
boxplot(diamonds_df$y, main="Ancho", xlab="ancho", ylab="mm")
boxplot(diamonds_df$z, main="Profundidad", xlab="profundidad", ylab="mm")
boxplot(diamonds_df$volume, main="Volumen", xlab="volumen", ylab="mm^3")
```

Observando los datos, vemos que existen datos que, claramente, suponen valores extremos que no difieren bastante de la media de la muestra, analizamos caso a caso.


## 4. Análisis de los datos.
### 4.1. Selección de los grupos de datos que se quieren analizar/comparar (planificación de los análisis a aplicar). 

### 4.2. Comprobación de la normalidad y homogeneidad de la varianza. 

En primer lugar, se realiza un estudio sobre la normalidad de las variables precio, altura, tabla, x, y, z y volumen.

Se realizará un estudio visual y, a continuación, un test Shapiro (considerado de los más potentes para el contraste de la normalidad).

>En el estudio visual se utilizarán histogramas de frecuencias relativas con curva de normalidad superpuesta

```{r,eval=TRUE,echo=TRUE}
#Variable peso
hist(diamonds_df$carat, main= "Peso del diamante", freq = FALSE, xlab = "Kilates", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$carat), sd=sd(diamonds_df$carat)), add=TRUE, col="red", lwd=3)

#Variable precio
hist(diamonds_df$price, main= "Precio del diamante", freq = FALSE, xlab = "Precio USD", col = "dark green", border="white")

#Variable altura
hist(diamonds_df$depth, main= "Altura del diamante", freq = FALSE, xlab = "z / media(x, y)", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$depth), sd=sd(diamonds_df$depth)), add=TRUE, col="red", lwd=3)

#Variable ancho
hist(diamonds_df$table, main= "Ancho del diamante", freq = FALSE, xlab = "% respecto al diámetro medio", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$table), sd=sd(diamonds_df$table)), add=TRUE, col="red", lwd=3)

#Variable "x"
hist(diamonds_df$x, main= "Longitud", freq = FALSE, xlab = "mm", col = "dark green", border="white")

#Variable "y"
hist(diamonds_df$y, main= "Ancho", freq = FALSE, xlab = "mm", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$y), sd=sd(diamonds_df$y)), add=TRUE, col="red", lwd=3)

#Variable "z"
hist(diamonds_df$z, main= "Profundidad", freq = FALSE, xlab = "mm", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$z), sd=sd(diamonds_df$z)), add=TRUE, col="red", lwd=3)

#Volumen
hist(diamonds_df$volume, main= "Volumen", freq = FALSE, xlab = "mm^3", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$volume), sd=sd(diamonds_df$volume)), add=TRUE, col="red", lwd=3)

```

Vemos que en el caso del precio seguiría una distribución exponencial negativa, por otra parte, la longitud no seguiría ninguna distribución apreciable.

Vamos a realizar el Test Shapiro a las variables que podrían asemejarse a una distribución normal, si atendemos a su gráfico.

```{r,eval=TRUE,echo=TRUE}
shapiro.test(diamonds_df$carat[1:5000])
shapiro.test(diamonds_df$depth[1:5000])
shapiro.test(diamonds_df$table[1:5000])
shapiro.test(diamonds_df$y[1:5000])
shapiro.test(diamonds_df$z[1:5000])
shapiro.test(diamonds_df$volume[1:5000])
```

A continuación, vamos a comprobar si la varianza es homogénea, es decir, cumple con la homocedasticidad, para ello, ya que las muestras nos son normales, vamos a utilizar el test de Fligner-Killeen




Vamos a realizar un estudio de normalidad sobre la variable corte, para ello vamos a asignar un valor numérico a cada uno de los niveles de la variable categorica "cut".

```{r}
table(diamonds_df$cut)

```


```{r,eval=TRUE,echo=TRUE}
diamonds_df$cut<-as.numeric(diamonds_df$cut)

#Variable corte
hist(diamonds_df$cut, main= "Calidad del corte", freq = FALSE, xlab = "Nivel de calidad", col = "dark green", border="white")
curve(dnorm(x, mean=mean(diamonds_df$cut), sd=sd(diamonds_df$cut)), add=TRUE, col="red", lwd=3)

#Test Shapiro
shapiro.test(diamonds_df$cut[1:5000])


```


### 4.3.  Aplicación de pruebas estadísticas para comparar los grupos de datos. En función de los datos y el objetivo del estudio, aplicar pruebas de contraste de hipótesis, correlaciones,  regresiones,  etc.  Aplicar  al  menos  tres  métodos  de  análisis diferentes. 

## 5. Representación de los resultados a partir de tablas y gráficas. 

## 6. Resolución  del  problema.  A  partir  de  los  resultados  obtenidos,  ¿cuáles  son  las conclusiones? ¿Los resultados permiten responder al problema? 































